Low-level programming language

A  low-level programming language  is a  programming language  that provides little or no  abstraction  from a computer's  instruction set architecture —commands or functions in the language map that are structurally similar to processor's instructions. Generally, this refers to either  machine code  or  assembly language . Because of the low (hence the word) abstraction between the language and machine language, low-level languages are sometimes described as being "close to the hardware". Programs written in low-level languages tend to be relatively  non-portable , due to being optimized for a certain type of system architecture. 
 Low-level languages can convert to machine code without a  compiler  or  interpreter  –  second-generation programming languages  use a simpler processor called an  assembler  – and the resulting code runs directly on the processor. A program written in a low-level language can be made to run very quickly, with a small  memory footprint . An equivalent program in a  high-level language  can be less efficient and use more memory. Low-level languages are simple, but considered difficult to use, due to numerous technical details that the programmer must remember. By comparison, a  high-level programming language  isolates execution semantics of a computer architecture from the specification of the program, which simplifies development.
 Contents 
 1   Machine code 
 2   Assembly language 
 3   Low-level programming in high-level languages 
 4   References 
 Machine code [ edit ] Machine code  is the only language a computer can process directly without a previous transformation. Currently, programmers almost never write programs directly in machine code, because it requires attention to numerous details that a high-level language handles automatically. Furthermore, it requires memorizing or looking up numerical codes for every instruction, and is extremely difficult to modify.
 True  machine code  is a stream of raw, usually  binary , data.  A programmer coding in "machine code" normally codes instructions and data in a more readable form such as  decimal ,  octal , or  hexadecimal  which is translated to internal format by a program called a  loader  or toggled into the computer's memory from a  front panel .
 Although few programs are written in machine languages, programmers often become adept at reading it through working with  core dumps  or debugging from the front panel.    
 Example: A function in hexadecimal representation of 32-bit  x86  machine code to calculate the  n th  Fibonacci number :
 Assembly language [ edit ] Second-generation languages provide one abstraction level on top of the machine code. In the early days of coding on computers like  TX-0  and  PDP-1 , the first thing MIT hackers did was to write assemblers. [1] 
 Assembly language  has little  semantics  or formal specification, being only a mapping of human-readable symbols, including symbolic addresses, to  opcodes ,  addresses , numeric constants,  strings  and so on. Typically, one  machine instruction  is represented as one line of assembly code.  Assemblers produce  object files  that can  link  with other object files or be  loaded  on their own.
 Most assemblers provide  macros  to generate common sequences of instructions.
 Example: The same  Fibonacci number  calculator as above, but in x86-64 assembly language using  AT&T syntax :
 In this code example, hardware features of the x86-64 processor (its  registers ) are named and manipulated directly. The function loads its input from  %edi  in accordance to the  System V ABI  and performs its calculation by manipulating values in the  EAX ,  EBX , and  ECX  registers until it has finished and returns.  Note that in this assembly language, there is no concept of returning a value. The result having been stored in the  EAX  register, the  RET  command simply moves code processing to the code location stored on the stack (usually the instruction immediately after the one that called this function) and it is up to the author of the calling code to know that this function stores its result in  EAX  and to retrieve it from there.  x86-64 assembly language imposes no standard for returning values from a function (and in fact, has no concept of a function); it is up to the calling code to examine state after the procedure returns if it needs to extract a value.
 Compare this with the same function in  C , a  high-level language :
 This code is very similar in structure to the assembly language example but there are significant differences in terms of abstraction:
 The input (parameter  n ) is an abstraction that does not specify any storage location on the hardware. In practice, the C compiler follows one of many possible   calling conventions  to determine a storage location for the input. 
 The assembly language version loads the input parameter from the stack into a register and in each iteration of the loop decrements the value in the register, never altering the value in the memory location on the stack.  The C compiler could load the parameter into a register and do the same or could update the value wherever it is stored. Which one it chooses is an implementation decision completely hidden from the code author (and one with no  side effects , thanks to C language standards). 
 The local variables a, b and c are abstractions that do not specify any specific storage location on the hardware.  The C compiler decides how to actually store them for the target architecture. 
 The return function specifies the value to return, but does not dictate  how  it is returned. The C compiler for any specific architecture implements a  standard  mechanism for returning the value.  Compilers for the x86 architecture typically (but not always) use the EAX register to return a value, as in the assembly language example (the author of the assembly language example has  chosen  to copy the C convention but assembly language does not require this). These abstractions make the C code compilable without modification on any architecture for which a C compiler has been written. The x86 assembly language code is specific to the x86 architecture.
 Low-level programming in high-level languages [ edit ] In the late 1960s,  high-level languages  such as  PL/S ,  BLISS ,  BCPL , extended  ALGOL  (for  Burroughs large systems ) and  C  included some degree of access to low-level programming functions. One method for this is  Inline assembly , in which assembly code is embedded in a high-level language that supports this feature.  Some of these languages also allow architecture-dependent  compiler optimization directives  to adjust the way a compiler uses the target processor architecture.
 References [ edit ] v t e Actor-based 
 Array 
 Aspect-oriented 
 Class-based 
 Concatenative 
 Concurrent 
 Dataflow 
 Declarative 
 Differentiable 
 Domain-specific 
 Dynamic 
 Esoteric 
 Event-driven 
 Extensible 
 Functional 
 Imperative 
 Logic 
 Macro 
 Metaprogramming 
 Object-based 
 Object-oriented 
 Pipeline 
 Procedural 
 Prototype-based 
 Reflective 
 Rule-based 
 Scripting 
 Stack-oriented 
 Synchronous 
 Tactile 
 Template Assembly 
 Compiled 
 Interpreted 
 Machine Low-level 
 High-level 
 Very high-level First 
 Second 
 Third 
 Fourth 
 Fifth Non-English-based 
 Visual v t e Assembly language 
 Comparison of assemblers 
 Disassembler 
 Instruction set 
 Low-level programming language 
 Machine code 
 Microassembler 
 x86 assembly language A86/A386 
 Flat Assembler  (FASM) 
 GNU Assembler  (GAS) 
 High Level Assembly  (HLA) 
 Microsoft Macro Assembler  (MASM) 
 Netwide Assembler  (NASM) 
 Turbo Assembler  (TASM) 
 Open Watcom Assembler  (WASM) Call stack 
 Flags 
 Carry flag 
 Direction flag 
 Interrupt flag 
 Overflow flag 
 Zero flag 
 Opcode 
 Program counter 
 Processor register 
 Calling conventions 
 Instruction listings 
 Registers Low-level programming languages Programming language classification Articles with short description Short description matches Wikidata Articles that may contain original research from March 2017 All articles that may contain original research Articles needing additional references from July 2015 All articles needing additional references Wikipedia articles in need of updating from December 2019 All Wikipedia articles in need of updating Articles with multiple maintenance issues Articles with example C code Navigation menu Not logged in Talk Contributions Create account Log in Article Talk Read Edit View history 
				 Search 
			 Main page Contents Current events Random article About Wikipedia Contact us Donate Help Learn to edit Community portal Recent changes Upload file What links here Related changes Upload file Special pages Permanent link Page information Cite this page Wikidata item Download as PDF Printable version العربية Azərbaycanca Bosanski Català Čeština Ελληνικά Español فارسی Français Gaeilge 한국어 Hrvatski Italiano עברית ქართული Kurdî Latviešu Lombard Magyar Македонски Монгол 日本語 Norsk bokmål Олык марий Polski Português Русский Simple English Slovenščina Српски / srpski Srpskohrvatski / српскохрватски Suomi Svenska ไทย Тоҷикӣ Türkçe Українська Tiếng Việt 粵語 中文 
	  This page was last edited on 12 March 2022, at 10:24  (UTC) . 
	 Text is available under the  Creative Commons Attribution-ShareAlike License 3.0 ;
additional terms may apply.  By using this site, you agree to the  Terms of Use  and  Privacy Policy . Wikipedia® is a registered trademark of the  Wikimedia Foundation, Inc. , a non-profit organization. 
 
	 Privacy policy 
	 About Wikipedia 
	 Disclaimers 
	 Contact Wikipedia 
	 Mobile view 
	 Developers 
	 Statistics 
	 Cookie statement 
 
	 
	 
